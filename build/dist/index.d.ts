// Generated by dts-bundle-generator v9.5.1

import { Placement } from '@floating-ui/dom';
import { Editor, EditorOptions } from '@tiptap/core';
import { TemplateResult } from 'lit-html';
import { Ref } from 'lit/directives/ref.js';

export type MenuItem = {
	title: string;
	icon: TemplateResult;
	action: (e: PointerEvent, dropdown: PdDropdown) => void;
};
export declare class PdDropdown extends HTMLElement {
	#private;
	connectedCallback(): void;
	disconnectCallback(): void;
	setPlacement(placement: Placement): void;
	getPlacement(): Placement;
	getReference(): HTMLElement | PdButton | undefined;
	renderHTML(html: TemplateResult): void;
	updatePosition(): Promise<void>;
	show(reference: HTMLElement): Promise<void>;
	hide(): void;
	toggle(reference: HTMLElement): void;
	onClickOutside(e: MouseEvent): void;
	render(): import("lit-html").RootPart | undefined;
}
export declare class PdModal extends HTMLElement {
	/**
	 * A reference to the element that activated the modal
	 */
	protected reference?: HTMLElement | PdButton;
	constructor();
	show(reference: HTMLElement | PdButton): void;
	hide(): void;
	toggle(reference: HTMLElement | PdButton): void;
	render(): void;
}
export declare class PdButton extends HTMLElement {
	/**
	 * Reference to TipTap editor
	 */
	protected editor: Editor;
	/**
	 * Reference to dropdown element
	 */
	protected dropdown: PdDropdown;
	/**
	 * Reference to modal element
	 */
	protected modal: PdModal;
	/**
	 * Button icon https://lucide.dev/icons/
	 */
	getIcon(): string;
	/**
	 * A function that runs each time the editor emits
	 * a transaction to check whether the button should be active
	 */
	isActive(): boolean;
	/**
	 * A `lit html` to render inside a `modal` or `dropdown`
	 */
	getTemplate(): string | TemplateResult | MenuItem[];
	/**
	 * A callback function that runs when clicking the button
	 *
	 * `modal` and `dropdown` dont have a `onClick` callback
	 */
	onClick(): void;
	/**
	 * Button type, `button`, `dropdown` or `modal`
	 *
	 * Default `button`
	 */
	getType(): "button" | "dropdown" | "modal";
	/**
	 * Used in the tooltip
	 *
	 * In a `modal` also used as header title
	 *
	 * @returns
	 */
	getTitle(): string;
	constructor(
	/**
	 * Reference to TipTap editor
	 */
	editor: Editor, 
	/**
	 * Reference to dropdown element
	 */
	dropdown: PdDropdown, 
	/**
	 * Reference to modal element
	 */
	modal: PdModal);
	onMount(): void;
	toggleCallback(): void;
	disconnectedCallback(): void;
	setActive(): void;
	setInactive(): void;
	toggleActive(): void;
}
export type ButtonGroup = {
	[key: string]: {
		el: HTMLElement;
		buttons: PdButton[];
	};
};
export declare class PdEditorToolbar extends HTMLElement {
	groups: ButtonGroup;
	registeredButtons: {
		[key: string]: PdButton;
	};
	constructor();
	connectedCallback(): void;
	/**
	 * Registers and adds a new button to the toolbar
	 *
	 * @param button
	 * @param editor
	 */
	addButton(groupName: keyof ButtonGroup, button: typeof PdButton, editor: PdEditor): void;
	/**
	 * Register a new group with buttons to the toolbar
	 *
	 * Existing groups must be unregistered first before overwriting
	 *
	 * @param name
	 * @param editor
	 * @param buttons
	 */
	registerGroup(name: string, editor: PdEditor, buttons?: typeof PdButton[]): void;
	/**
	 * Removes a group from the toolbar
	 *
	 * All buttons registered on this group will be deleted aswell
	 *
	 * @param name
	 */
	unregisterGroup(name: string): void;
	/**
	 * Rerenders all buttons
	 *
	 * Some events requires the toolbar from rerendering, like when you add or remove a button
	 */
	rerender(): void;
}
export declare class PdEditor extends HTMLElement {
	/**
	 * Reference to PdEditorToolbar
	 *
	 * @type {PdEditorToolbar}
	 */
	readonly toolbar: PdEditorToolbar;
	/**
	 * Reference to PdDropdown
	 *
	 * @type {PdDropdown}
	 */
	readonly dropdown: PdDropdown;
	/**
	 * Reference to PdModal
	 *
	 * @type {PdModal}
	 */
	readonly modal: PdModal;
	/**
	 * Reference to TipTap editor
	 *
	 * @type {Editor}
	 */
	protected editor: Editor;
	constructor(
	/**
	 * Reference to PdEditorToolbar
	 *
	 * @type {PdEditorToolbar}
	 */
	toolbar: PdEditorToolbar, 
	/**
	 * Reference to PdDropdown
	 *
	 * @type {PdDropdown}
	 */
	dropdown: PdDropdown, 
	/**
	 * Reference to PdModal
	 *
	 * @type {PdModal}
	 */
	modal: PdModal);
	connectedCallback(): void;
	renderedCallback(): void;
	setEditor(editor: Editor): void;
	getEditor(): Editor;
}
export declare class PdButtonBold extends PdButton {
	getIcon(): string;
	onClick(): void;
	isActive(): boolean;
}
export declare class PdButtonBulletList extends PdButton {
	getIcon(): string;
	getTitle(): string;
	onClick(): void;
	isActive(): boolean;
}
export declare class PdButtonHeading extends PdButton {
	getType(): "dropdown";
	getIcon(): string;
	isActive(): boolean;
	getTemplate(): {
		title: string;
		icon: import("lit-html").TemplateResult<1>;
		action: () => void;
	}[];
}
export declare class PdButtonImage extends PdButton {
	/**
	 * A reference to the HTMLFormElement
	 *
	 * @link https://lit.dev/docs/api/directives/#createRef
	 */
	private formRef;
	/**
	 * Which type of button we are creating?
	 * It can be one of 'button', 'dropdown' or 'modal'. Default is button
	 *
	 * @optional
	 * @default button
	 */
	getType(): "modal";
	/**
	 * Should be an SVG.
	 *
	 * If you use font icons, that works too (<i class="fa fa-image"></i>)
	 *
	 * All icons used by the editor are from https://lucide.dev/icons/
	 * with a stroke width of 1px and the size being 18px
	 *
	 * @required
	 */
	getIcon(): string;
	/**
	 * The title is used as a tooltip when hovering the button
	 *
	 * Beside being used as tooltip, its also used as header title in a modal
	 *
	 * @required
	 */
	getTitle(): string;
	/**
	 * A function that that checks when the button should be in an 'active' state
	 * Since we use TipTap under the hood, we can use TipTaps `.isActive()` method
	 *
	 * @required
	 */
	isActive(): boolean;
	/**
	 * The callback we call when we submit the form in the modal
	 */
	setImage(e: SubmitEvent): void;
	/**
	 * The returned string of this method will be rendered as body
	 * of the modal
	 */
	getTemplate(): import("lit-html").TemplateResult<1>;
	/**
	 * We can get the src attribute of an inserted image using this code
	 *
	 * @link https://tiptap.dev/docs/editor/api/editor#getattributes
	 */
	get valueSrc(): any;
}
export declare class PdButtonItalic extends PdButton {
	getIcon(): string;
	onClick(): void;
	isActive(): boolean;
}
export declare class PdButtonLink extends PdButton {
	formRef: Ref<HTMLFormElement>;
	constructor(editor: Editor, dropdown: PdDropdown, modal: PdModal);
	getType(): "modal";
	getIcon(): string;
	getTitle(): string;
	isActive(): boolean;
	setLink(e: SubmitEvent): void;
	unsetLink(): void;
	getTemplate(): import("lit-html").TemplateResult<1>;
	showDropdown(): void;
	get textValue(): string;
	get urlValue(): any;
}
export declare class PdButtonOrderedList extends PdButton {
	getIcon(): string;
	getTitle(): string;
	onClick(): void;
	isActive(): boolean;
}
export declare class PdButtonStrike extends PdButton {
	getIcon(): string;
	onClick(): void;
	isActive(): boolean;
}
export declare class PdButtonTable extends PdButton {
	protected button: HTMLButtonElement;
	onMount(): void;
	getTitle(): string;
	getIcon(): string;
	onClick(): void;
	isActive(): boolean;
	showButton(): void;
	showDropdown(): void;
}
export declare class PdButtonUnderline extends PdButton {
	getIcon(): string;
	getTitle(): string;
	onClick(): void;
	isActive(): boolean;
}
export type ToolbarButtonsConfigArray = typeof PdButton[][];
export type ToolbarButtonsConfigNamed = {
	[key: string]: typeof PdButton[];
};
export type EditorConfig = {
	tiptap: Partial<EditorOptions>;
	toolbar: {
		buttons: ToolbarButtonsConfigArray | ToolbarButtonsConfigNamed;
	};
};
export declare const defaultConfig: EditorConfig;
/**
 * Create a new editor instance
 *
 * @param element   - Element which will be replaced with the editor
 * @param config
 * @returns {PdEditor}
 */
export declare const createEditor: <T extends EditorConfig["toolbar"]>(element: HTMLElement, config?: EditorConfig) => PdEditor;
export declare const getDropdown: () => PdDropdown;
export declare const getModal: () => PdModal;

export {};
