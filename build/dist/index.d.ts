// Generated by dts-bundle-generator v9.5.1

import { Placement } from '@floating-ui/dom';
import { Editor, EditorOptions } from '@tiptap/core';
import { TemplateResult } from 'lit';

declare class PdButton extends HTMLElement {
	/**
	 * Reference to TipTap editor
	 */
	protected editor: PdEditor;
	/**
	 * Button icon https://lucide.dev/icons/
	 */
	getIcon(): string;
	/**
	 * A function that runs each time the editor emits
	 * a transaction to check whether the button should be active
	 */
	isActive(): boolean;
	/**
	 * A `lit html` to render inside a `modal` or `dropdown`
	 */
	getTemplate(): string | TemplateResult | MenuItem[];
	/**
	 * A callback function that runs when clicking the button
	 *
	 * `modal` and `dropdown` dont have a `onClick` callback
	 */
	onClick(): void;
	/**
	 * Button type, `button`, `dropdown` or `modal`
	 *
	 * Default `button`
	 */
	getType(): "button" | "dropdown" | "modal";
	/**
	 * Used in the tooltip
	 *
	 * In a `modal` also used as header title
	 *
	 * @returns
	 */
	getTitle(): string;
	constructor(
	/**
	 * Reference to TipTap editor
	 */
	editor: PdEditor);
	connectedCallback(): void;
	disconnectedCallback(): void;
	setActive(): void;
	setInactive(): void;
	toggleActive(): void;
}
export type MenuItem = {
	title: string;
	icon: TemplateResult;
	action: (e: PointerEvent, dropdown: PdDropdown) => void;
};
declare class PdDropdown extends HTMLElement {
	#private;
	connectedCallback(): void;
	disconnectCallback(): void;
	setPlacement(placement: Placement): void;
	getPlacement(): Placement;
	getReference(): HTMLElement | PdButton | undefined;
	renderHTML(html: TemplateResult): void;
	updatePosition(): Promise<void>;
	show(reference: HTMLElement): Promise<void>;
	hide(): void;
	toggle(reference: HTMLElement): void;
	onClickOutside(e: MouseEvent): void;
	render(): import("lit").RootPart | undefined;
}
declare class PdModal extends HTMLElement {
	/**
	 * A reference to the element that activated the modal
	 */
	protected reference?: HTMLElement | PdButton;
	constructor();
	show(reference: HTMLElement | PdButton): void;
	hide(): void;
	toggle(reference: HTMLElement | PdButton): void;
	render(): void;
}
export type ButtonGroup = {
	[key: string]: {
		el: HTMLElement;
		buttons: PdButton[];
	};
};
declare class PdEditorToolbar extends HTMLElement {
	readonly editor: PdEditor;
	groups: ButtonGroup;
	constructor(editor: PdEditor);
	connectedCallback(): void;
	/**
	 * Registers and adds a new button to the toolbar
	 *
	 * @param button
	 * @param editor
	 */
	addButton(groupName: keyof ButtonGroup, button: typeof PdButton): void;
	/**
	 * Removes a button from the toolbar
	 *
	 * @param name      - name of the button to remove
	 */
	removeButton(name: string): void;
	/**
	 * Register a new group with buttons to the toolbar
	 *
	 * Existing groups must be unregistered first before overwriting
	 *
	 * @param name
	 * @param editor
	 * @param buttons
	 */
	registerGroup(name: string, buttons?: typeof PdButton[]): void;
	/**
	 * Removes a group from the toolbar
	 *
	 * All buttons registered on this group will be deleted aswell
	 *
	 * @param name
	 */
	unregisterGroup(name: string): void;
}
declare class PdEditor extends HTMLElement {
	readonly config: EditorConfig;
	/**
	 * The Tiptap editor instance used for text editing.
	 *
	 * @readonly {Editor}
	 */
	readonly tiptap: Editor;
	/**
	 * The toolbar component for text formatting options.
	 *
	 * @readonly {PdEditorToolbar}
	 */
	readonly toolbar: PdEditorToolbar;
	/**
	 * Reference to dropdown element
	 */
	readonly dropdown: PdDropdown;
	/**
	 * Reference to modal element
	 */
	readonly modal: PdModal;
	constructor(element: HTMLElement, config: EditorConfig);
	connectedCallback(): void;
}
export type EditorClasses = {
	editor: string;
	toolbar: string;
	button: string;
	modal: {
		backdrop: string;
		dialog: string;
	};
	dropdown: {
		modal: string;
		item: string;
	};
};
export type ToolbarButtonsConfigNamed = {
	[key: string]: typeof PdButton[];
};
export type EditorConfig = {
	tiptap: Partial<EditorOptions>;
	toolbar: {
		buttons: ToolbarButtonsConfigNamed;
	};
	classes: Partial<EditorClasses>;
};
/**
 * Create a new editor instance
 *
 * @param element   - Element which will be replaced with the editor
 * @param options
 * @returns {PdEditor}
 */
export declare const createEditor: (element: HTMLElement, options?: Partial<EditorConfig>) => PdEditor;
export declare const getDropdown: () => PdDropdown;
export declare const getModal: () => PdModal;

export {};
