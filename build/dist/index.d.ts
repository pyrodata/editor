// Generated by dts-bundle-generator v9.5.1

import { Placement } from '@floating-ui/dom';
import { Editor, EditorOptions } from '@tiptap/core';
import { TemplateResult } from 'lit';

export type MenuItem = {
	title: string;
	icon: TemplateResult;
	action: (e: PointerEvent, dropdown: PdDropdown) => void;
};
declare class PdDropdown extends HTMLElement {
	#private;
	connectedCallback(): void;
	disconnectCallback(): void;
	setPlacement(placement: Placement): void;
	getPlacement(): Placement;
	getReference(): HTMLElement | PdButton | undefined;
	renderHTML(html: TemplateResult): void;
	updatePosition(): Promise<void>;
	show(reference: HTMLElement): Promise<void>;
	hide(): void;
	toggle(reference: HTMLElement): void;
	onClickOutside(e: MouseEvent): void;
	render(): import("lit").RootPart | undefined;
}
declare class PdModal extends HTMLElement {
	/**
	 * A reference to the element that activated the modal
	 */
	protected reference?: HTMLElement | PdButton;
	constructor();
	show(reference: HTMLElement | PdButton): void;
	hide(): void;
	toggle(reference: HTMLElement | PdButton): void;
	render(): void;
}
declare class PdButton extends HTMLElement {
	/**
	 * Reference to TipTap editor
	 */
	protected editor: Editor;
	/**
	 * Reference to dropdown element
	 */
	protected dropdown: PdDropdown;
	/**
	 * Reference to modal element
	 */
	protected modal: PdModal;
	/**
	 * Button icon https://lucide.dev/icons/
	 */
	getIcon(): string;
	/**
	 * A function that runs each time the editor emits
	 * a transaction to check whether the button should be active
	 */
	isActive(): boolean;
	/**
	 * A `lit html` to render inside a `modal` or `dropdown`
	 */
	getTemplate(): string | TemplateResult | MenuItem[];
	/**
	 * A callback function that runs when clicking the button
	 *
	 * `modal` and `dropdown` dont have a `onClick` callback
	 */
	onClick(): void;
	/**
	 * Button type, `button`, `dropdown` or `modal`
	 *
	 * Default `button`
	 */
	getType(): "button" | "dropdown" | "modal";
	/**
	 * Used in the tooltip
	 *
	 * In a `modal` also used as header title
	 *
	 * @returns
	 */
	getTitle(): string;
	constructor(
	/**
	 * Reference to TipTap editor
	 */
	editor: Editor, 
	/**
	 * Reference to dropdown element
	 */
	dropdown: PdDropdown, 
	/**
	 * Reference to modal element
	 */
	modal: PdModal);
	connectedCallback(): void;
	disconnectedCallback(): void;
	setActive(): void;
	setInactive(): void;
	toggleActive(): void;
}
export type ButtonGroup = {
	[key: string]: {
		el: HTMLElement;
		buttons: PdButton[];
	};
};
declare class PdEditorToolbar extends HTMLElement {
	groups: ButtonGroup;
	registeredButtons: {
		[key: string]: PdButton;
	};
	connectedCallback(): void;
	/**
	 * Registers and adds a new button to the toolbar
	 *
	 * @param button
	 * @param editor
	 */
	addButton(groupName: keyof ButtonGroup, button: typeof PdButton, editor: PdEditor): void;
	/**
	 * Removes a button from the toolbar
	 *
	 * @param name      - name of the button to remove
	 */
	removeButton(name: string): void;
	/**
	 * Register a new group with buttons to the toolbar
	 *
	 * Existing groups must be unregistered first before overwriting
	 *
	 * @param name
	 * @param editor
	 * @param buttons
	 */
	registerGroup(name: string, editor: PdEditor, buttons?: typeof PdButton[]): void;
	/**
	 * Removes a group from the toolbar
	 *
	 * All buttons registered on this group will be deleted aswell
	 *
	 * @param name
	 */
	unregisterGroup(name: string): void;
	/**
	 * Rerenders the toolbar
	 */
	rerender(): void;
}
declare class PdEditor extends HTMLElement {
	/**
	 * Reference to PdEditorToolbar
	 *
	 * @type {PdEditorToolbar}
	 */
	readonly toolbar: PdEditorToolbar;
	/**
	 * Reference to PdDropdown
	 *
	 * @type {PdDropdown}
	 */
	readonly dropdown: PdDropdown;
	/**
	 * Reference to PdModal
	 *
	 * @type {PdModal}
	 */
	readonly modal: PdModal;
	/**
	 * Reference to TipTap editor
	 *
	 * @type {Editor}
	 */
	protected editor: Editor;
	constructor(
	/**
	 * Reference to PdEditorToolbar
	 *
	 * @type {PdEditorToolbar}
	 */
	toolbar: PdEditorToolbar, 
	/**
	 * Reference to PdDropdown
	 *
	 * @type {PdDropdown}
	 */
	dropdown: PdDropdown, 
	/**
	 * Reference to PdModal
	 *
	 * @type {PdModal}
	 */
	modal: PdModal);
	connectedCallback(): void;
	setEditor(editor: Editor): void;
	getEditor(): Editor;
}
export type ToolbarButtonsConfigArray = typeof PdButton[][];
export type ToolbarButtonsConfigNamed = {
	[key: string]: typeof PdButton[];
};
export type EditorConfig = {
	tiptap: Partial<EditorOptions>;
	toolbar: {
		buttons: ToolbarButtonsConfigArray | ToolbarButtonsConfigNamed;
	};
};
/**
 * Create a new editor instance
 *
 * @param element   - Element which will be replaced with the editor
 * @param config
 * @returns {PdEditor}
 */
export declare const createEditor: (element: HTMLElement, config?: Partial<EditorConfig>) => PdEditor;
export declare const getDropdown: () => PdDropdown;
export declare const getModal: () => PdModal;

export {};
